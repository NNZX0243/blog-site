// module-loader.js

/**
 * HTML模块加载器
 *
 * 该脚本允许您通过JavaScript加载外部HTML片段到您的页面中，
 * 实现HTML的模块化和代码复用。
 *
 * 功能特点：
 * 1. 异步加载HTML内容
 * 2. 支持多个模块同时加载
 * 3. 详细的错误处理和状态反馈
 * 4. 加载动画和状态提示
 * 5. 缓存机制优化性能
 */

// 模块加载状态跟踪
const ModuleLoader = {
	// 模块缓存
	cache: {},

	// 默认配置
	config: {
		loadingClass: 'module-loading',
		errorClass: 'module-error',
		loadedClass: 'module-loaded',
		minLoadTime: 500, // 最小加载时间（毫秒），确保动画可见
		debugMode: false,
		useCache: true,
	},

	// 初始化函数（可选）
	init(options) {
		// 合并自定义配置
		Object.assign(this.config, options)

		if (this.config.debugMode) {
			console.log('[ModuleLoader] 初始化完成，配置:', this.config)
		}
	},

	/**
	 * 加载HTML模块到指定的DOM元素中
	 * @param {string} moduleId - 目标容器的ID
	 * @param {string} path - HTML文件路径
	 * @param {Object} options - 可选配置项
	 *
	 * 配置项：
	 *   - beforeLoad: 加载前回调
	 *   - afterLoad: 加载后回调
	 *   - afterInsert: 插入内容后回调
	 *   - errorHandler: 自定义错误处理
	 *   - minLoadTime: 最小加载时间（覆盖全局配置）
	 */
	load(moduleId, path, options = {}) {
		const startTime = performance.now()
		const container = document.getElementById(moduleId)
		const config = { ...this.config, ...options }
		const minLoadTime = config.minLoadTime

		if (!container) {
			console.error(
				`[ModuleLoader] 错误：找不到ID为"${moduleId}"的容器元素`
			)
			return Promise.reject(`容器未找到: ${moduleId}`)
		}

		// 检查缓存
		if (config.useCache && this.cache[path]) {
			if (config.debugMode) {
				console.log(`[ModuleLoader] 使用缓存内容: ${path}`)
			}

			this._insertContent(container, this.cache[path])
			if (config.afterInsert) config.afterInsert(container, path)
			return Promise.resolve()
		}

		// 加载前状态设置
		container.innerHTML = this._createLoadingIndicator(moduleId)
		container.classList.add(config.loadingClass)
		container.classList.remove(config.errorClass, config.loadedClass)

		// 执行beforeLoad回调
		if (config.beforeLoad) config.beforeLoad(container, path)

		// 创建加载结果承诺
		return new Promise((resolve, reject) => {
			// 开始加载
			const requestTime = Date.now()

			// 实际项目中应使用fetch，这里为演示目的使用模拟函数
			this._fetchModuleContent(path)
				.then((content) => {
					// 计算实际加载时间
					const loadTime = Date.now() - requestTime
					const remainingTime = Math.max(0, minLoadTime - loadTime)

					// 确保加载时间至少为minLoadTime
					setTimeout(() => {
						// 缓存内容
						if (config.useCache) {
							this.cache[path] = content
						}

						// 插入内容
						this._insertContent(container, content)
						container.classList.remove(config.loadingClass)
						container.classList.add(config.loadedClass)

						if (config.debugMode) {
							const totalTime = performance.now() - startTime
							console.log(
								`[ModuleLoader] 加载完成: ${path} (${totalTime.toFixed(
									1
								)}ms)`
							)
						}

						// 执行回调
						if (config.afterLoad) config.afterLoad(container, path)
						if (config.afterInsert)
							config.afterInsert(container, path)

						resolve()
					}, remainingTime)
				})
				.catch((error) => {
					container.innerHTML = this._createErrorDisplay(error, path)
					container.classList.remove(config.loadingClass)
					container.classList.add(config.errorClass)

					if (config.debugMode) {
						const totalTime = performance.now() - startTime
						console.error(
							`[ModuleLoader] 加载失败: ${path} (${totalTime.toFixed(
								1
							)}ms)`,
							error
						)
					}

					// 自定义错误处理
					if (config.errorHandler) {
						config.errorHandler(error, container, path)
					} else {
						console.error(
							`[ModuleLoader] 加载模块错误 (${path}):`,
							error
						)
					}

					reject(error)
				})
		})
	},

	// 创建加载指示器
	_createLoadingIndicator(moduleId) {
		return `
            <div class="loader-container" data-module="${moduleId}">
                <div class="loader-spinner"></div>
                <div class="loader-text">加载模块中...</div>
            </div>
        `
	},

	// 创建错误显示
	_createErrorDisplay(error, path) {
		return `
            <div class="error-container">
                <div class="error-icon">⚠️</div>
                <h3 class="error-title">模块加载失败</h3>
                <p class="error-message">无法加载模块: ${path}</p>
                <p class="error-details">错误原因: ${
					error.message || '未知错误'
				}</p>
                <button class="error-retry">重新加载</button>
            </div>
        `
	},

	// 插入内容到容器
	_insertContent(container, content) {
		container.innerHTML = content

		// 重新绑定动态生成元素的事件
		this._bindRetryButtons(container)
	},

	// 绑定重试按钮事件
	_bindRetryButtons(container) {
		container.querySelectorAll('.error-retry').forEach((button) => {
			button.addEventListener('click', () => {
				const moduleId = container.id
				const path = container
					.querySelector('.error-message')
					.textContent.replace('无法加载模块: ', '')

				// 重新加载
				if (path) {
					this.load(moduleId, path)
				}
			})
		})
	},

	// 模拟获取模块内容 - 实际项目中替换为真实fetch
	_fetchModuleContent(path) {
		return new Promise((resolve, reject) => {
			// 在实际项目中，这里应该使用:
			fetch(path).then((response) => {
				if (!response.ok) throw new Error('网络响应错误')
				return response.text()
			})

			// // 这里是演示用的模拟函数
			// const mockModules = {
			// 	'header.html': `
			//         <header>
			//             <div class="header-content">
			//                 <div class="logo">网站LOGO</div>
			//                 <nav>
			//                     <ul>
			//                         <li><a href="index.html">首页</a></li>
			//                         <li><a href="about.html">关于我们</a></li>
			//                         <li><a href="services.html">服务</a></li>
			//                         <li><a href="contact.html">联系我们</a></li>
			//                     </ul>
			//                 </nav>
			//             </div>
			//         </header>
			//     `,

			// 	'footer.html': `
			//         <footer>
			//             <div class="footer-content">
			//                 <div class="copyright">&copy; 2023 公司名称. 保留所有权利.</div>
			//                 <div class="footer-links">
			//                     <a href="privacy.html">隐私政策</a>
			//                     <a href="terms.html">使用条款</a>
			//                 </div>
			//             </div>
			//         </footer>
			//     `,
			// }

			// 模拟网络延迟
			// setTimeout(() => {
			// 	if (mockModules[path]) {
			// 		resolve(mockModules[path])
			// 	} else {
			// 		reject(new Error(`找不到模块: ${path}`))
			// 	}
			// }, 300 + Math.random() * 500) // 随机延迟300-800ms
		})
	},

	/**
	 * 从缓存中清除特定模块
	 * @param {string} path - 要清除的模块路径
	 */
	clearCache(path) {
		if (this.cache[path]) {
			delete this.cache[path]
			if (this.config.debugMode) {
				console.log(`[ModuleLoader] 清除缓存: ${path}`)
			}
			return true
		}
		return false
	},

	/**
	 * 清除所有模块缓存
	 */
	clearAllCache() {
		const count = Object.keys(this.cache).length
		this.cache = {}
		if (this.config.debugMode) {
			console.log(`[ModuleLoader] 清除所有缓存 (${count}项)`)
		}
		return count
	},
}

// 将ModuleLoader添加到window对象
window.ModuleLoader = ModuleLoader

// 自动初始化
document.addEventListener('DOMContentLoaded', () => {
	ModuleLoader.init()

	// 自动加载data-module属性的元素
	document.querySelectorAll('[data-module]').forEach((el) => {
		const moduleId = el.id
		const path = el.getAttribute('data-module')

		if (moduleId && path) {
			ModuleLoader.load(moduleId, path, {
				afterInsert: (container) => {
					if (container.tagName === 'HEADER') {
						// 头部加载后的操作
					}
				},
			})
		}
	})
})
